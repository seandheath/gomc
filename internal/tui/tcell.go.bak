package tui

import (
	"log"
	"time"

	"github.com/gdamore/tcell/v2"
	"github.com/gdamore/tcell/views"
)

const SLEEP_INTERVAL = time.Millisecond * 10

var app = &views.Application{}
var tui = &TUI{}

type TUI struct {
	terminal *model
	windows  map[string]*window
	input    *views.SimpleStyledText
	views.Panel
}

type window struct {
	view  *views.CellView
	model *model
}

type model struct {
	x, y       int
	endx, endy int
	hide       bool
	enable     bool
	loc        string
}

func NewTUI() *TUI {
	t := &TUI{}

	t.windows["main"] = t.NewWindow(0, 0, 100, 100)
	t.input = views.NewSimpleStyledText()

	s, err := tcell.NewScreen()
	if err != nil {
		log.Fatalf("%+v", err)
	}

	if err := s.Init(); err != nil {
		log.Fatalf("%+v", err)
	}

	style := tcell.StyleDefault.
		Background(tcell.ColorReset).
		Foreground(tcell.ColorReset)
	s.SetStyle(style)
	s.EnableMouse()
	s.Clear()

	return t
}

func (t *TUI) NewWindow(x, y, width, height int) *window {
	m := &model{
		x:    x,
		y:    y,
		endx: x + width,
		endy: y + height,
	}
	v := views.NewCellView()
	v.SetModel(m)
	v.SetStyle(tcell.StyleDefault.Background(tcell.ColorBlack))
	w := &window{
		view:  v,
		model: m,
	}
	return w
}

func (t *TUI) drawText(x1, y1, x2, y2 int, text string, style tcell.Style) {
	row := y1
	col := x1
	for _, r := range []rune(text) {
		t.screen.SetContent(col, row, r, nil, t.style)
		col++
		// If column has reached the end of the bottom right corner move to the next row
		// and reset the column to the leftmost position.
		if col >= x2 {
			row++
			col = x1
		}
		// If row has passed the bottom right corner, stop.
		if row > y2 {
			break
		}
	}
}

func (t *TUI) print(w *window, text string) {
	w.content += text
}

func (t *TUI) drawWindow(w *window, text string) {

	x1 := w.x1
	y1 := w.y1
	x2 := w.x2
	y2 := w.y2

	// If rows/cols are reversed, flip them
	if y2 < y1 {
		y1, y2 = y2, y1
	}
	if x2 < x1 {
		x1, x2 = x2, x1
	}

	// Fill background with spaces
	for row := y1; row <= y2; row++ {
		for col := x1; col <= x2; col++ {
			t.screen.SetContent(col, row, ' ', nil, t.style)
		}
	}

	// Draw borders
	if w.border {
		for col := x1; col <= x2; col++ {
			t.screen.SetContent(col, y1, tcell.RuneHLine, nil, t.style)
			t.screen.SetContent(col, y2, tcell.RuneHLine, nil, t.style)
		}
		for row := y1 + 1; row < y2; row++ {
			t.screen.SetContent(x1, row, tcell.RuneVLine, nil, t.style)
			t.screen.SetContent(x2, row, tcell.RuneVLine, nil, t.style)
		}

		// Only draw corners if necessary
		if y1 != y2 && x1 != x2 {
			t.screen.SetContent(x1, y1, tcell.RuneULCorner, nil, t.style)
			t.screen.SetContent(x2, y1, tcell.RuneURCorner, nil, t.style)
			t.screen.SetContent(x1, y2, tcell.RuneLLCorner, nil, t.style)
			t.screen.SetContent(x2, y2, tcell.RuneLRCorner, nil, t.style)
		}
	}

	// Redraw the canvas inside the window, increment each dimension inside by 1
	t.drawText(x1+1, y1+1, x2-1, y2-1, text)
}

func (t *TUI) Print(windowName string, text string) {
	if w, ok := t.windows[windowName]; ok {
		t.drawWindow(w, text)
	} else {
		t.PrintError("window not found")
	}
}

func (t *TUI) PrintError(text string) {
	t.Print("main", "\n"+text)
}

func (t *TUI) Exit() {
	t.screen.Fini()
}

func (t *TUI) Run() {
	// Main loop
	for {
		// Update the screen
		t.screen.Show()

		// Poll for event
		ev := t.screen.PollEvent()

		// Process event
		switch ev := ev.(type) {
		case *tcell.EventResize:
			t.screen.Sync()
		case *tcell.EventKey:
			t.handleKey(ev)
		case *tcell.EventMouse:
			t.handleMouse(ev)
		}
	}
}

func (t *TUI) handleKey(ev *tcell.EventKey) {
	switch ev.Key() {
	case tcell.KeyCtrlC:
		t.Exit()
	}
}

func (t *TUI) handleMouse(ev *tcell.EventMouse) {

}
